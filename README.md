#Java-Concurrency-Sample.

###&emsp;&emsp;Java并发编程实例代码,基于&lt;&lt;Java并发编程实战&gt;&gt;一书.

---
下面是关于本示例代码的简单总结:
---
###&emsp;Chapter1:线程安全性
&emsp;&emsp;1).线程安全性的本质问题:对**状态**访问操作进行并发管理,特别是对**共享的(shared)**和**可变的(Mutable)**状态的管理.

&emsp;&emsp;2).竞态条件(Race Condition)问题:<br/>
&emsp;&emsp;&emsp;&emsp;1.Check-Then-Act:<br/>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;基于一种可能已经过时的观察结果来执行一些操作,很显然,这些操作可能导致程序出现不一致的情况.<br/>
&emsp;&emsp;&emsp;&emsp;2.读取-修改-写入操作:<br/>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;基于对象之前的状态来定义对象状态的转移.

&emsp;&emsp;3).复合操作:即使我们解决了竞态条件问题(通过使用一些原子类)，但当存在多个有逻辑关系的状态时,仅仅单独的解决每个状态的竞态条件问题是不够的。多个状态之间的复合操作仍然可能出现线程安全问题.<br/>
&emsp;&emsp;&emsp;竞态条件关注的是一个状态变量的线程安全问题。复合操作关注的是多个状态变量(它们之间往往有逻辑联系)的线程安全问题.

&emsp;&emsp;4).原子性：所有上面所述的安全性问题都需要使用原子性的操作来解决.而实现原子性操作的方式就是加锁机制.

&emsp;&emsp;2).加锁机制(内置锁)：同步代码块包含两部分的内容：一个作为锁的对象引用(任何非null对象都可能作为锁)，一个作为由这个锁保护的代码块。Java的内置锁相当于一种互斥锁，这意味着最多只有一个线程能持有这个锁。

---
###&emsp;Chapter2:对象的共享

&emsp;&emsp;&emsp;1.可见性/重排序/java内存模型问题：在构建多线程并发程序中,除了上一章简单讨论的由于非原子操作导致的共享资源失效问题，可见性也是一个需要注意并解决的问题。

&emsp;&emsp;&emsp;可见性问题又叫重排序问题，指即使一个线程对值的修改操作先于另一个线程对此共享值的读取操作。读线程也不一定会看见那个早于它的写线程设置过的值。

&emsp;&emsp;&emsp;最根本的原因在于当一个线程访问一个内存中共享数据时,会先在本线程内存中copy一个副本进行操作。最后再将新值更新回共享内存。问题在于最后的更新操作可能由于指令重排序而延后执行。

&emsp;&emsp;&emsp;2.volatile变量：一种比synchronized更轻量级的同步机制.仅仅用于确保内存可见性,但无法实现原子操作.

&emsp;&emsp;&emsp;3.线程封闭技术：通过设置局部变量和ThreadLocal机制将状态封闭于单个线程中,从而避免线程安全问题.

&emsp;&emsp;&emsp;4.不可变类(Immutable Object)：每当需要对**一组**数据以原子方式执行某个操作时,就可以考虑创建一个不可变类来封装这些状态,通过不可变类的手段来避免线程安全性。这种机制加上volatile的内存可见性可以在无需加锁的情况下实现并发读/写安全。

&emsp;&emsp;&emsp;对于不可变类的内部任然可以使用可变对象来管理它们.**组合了不可变对象的程序仍然可以通过用新对象替换的手段来实现状态的更新。**

---
###Chapter3:对象的组合.

&emsp;&emsp;&emsp;本章可以说是对前两章的总结：在这里，涉及3中同步策略/模式。

&emsp;&emsp;&emsp;1.组合可变且不安全的对象：在这种情况下，我们使用Java监视器模式来构建线程安全。我们把对象的可变状态都封装起来,并使用对象的内置锁来保护。(HashTable和Vector)

&emsp;&emsp;&emsp;2.组合不可变对象：在这种情况下，我们可以直接发布这些共享数据。但对其状态的更新要通过用新对象替换来实现。

&emsp;&emsp;&emsp;3.组合可变但线程安全的对象：这种实现将安全性交给了类本身来实现。这时，我们可以直接发布这些对象。

&emsp;&emsp;&emsp;这里涉及到一种并发读/写问题：就是说，当一个线程在更新状态时，我们到底该不该让其他线程并发读取这个状态呢。这里有几种机制：第一种是我们不让读/写线程并发操作，这种实现是通过给更新和读取操作都加锁(synchronized)来实现。第二种是我们允许并发读/写，但要保证读取到的数据的一致性，我们必然不能直接读取正在修改的那块内存数据，所以我们需要去读取最近一个修改前的副本数据。第一种情况并发性能会很好，但可能会出现**脏读**问题，第二种情况虽然保证数据读取完全的一致，但并发性能会差。这种互斥的实现不仅无法并发写/读，甚至无法并发读/读，这是一种强硬的加锁机制。当然我们不能简单的说哪种方式更好，这就像数据库的隔离级别一样，要根据不同的情况去选择。

---
###&emsp;Chapter4:避免活跃性危险 - 锁顺序死锁(Lock-Ordering DeadLock)
&emsp;&emsp;&emsp;本章关注锁顺序死锁问题，死锁的原因在于：**两个线程以不同的顺序获取相同的锁。如果按照相同的顺序来请求锁，就不会出现循环的加锁依赖性。**

---
###&emsp;&emsp;
